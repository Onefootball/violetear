{
  "name": "Violetear",
  "tagline": "Go HTTP router",
  "body": "[![GoDoc](https://godoc.org/github.com/nbari/violetear?status.svg)](https://godoc.org/github.com/nbari/violetear)\r\n[![Build Status](https://travis-ci.org/nbari/violetear.svg?branch=master)](https://travis-ci.org/nbari/violetear)\r\n[![Coverage Status](https://coveralls.io/repos/nbari/violetear/badge.svg?branch=develop&service=github)](https://coveralls.io/github/nbari/violetear?branch=develop)\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/nbari/violetear)](https://goreportcard.com/report/github.com/nbari/violetear)\r\n\r\n# violetear\r\nGo HTTP router\r\n\r\n### Design Goals\r\n* Keep it simple and small, avoiding extra complexity at all cost. [KISS](https://en.wikipedia.org/wiki/KISS_principle)\r\n* Support for static and dynamic routing.\r\n* Easy middleware compatibility so that it satisfies the http.Handler interface.\r\n* Common context between middleware.\r\n* Trace Request-ID per request.\r\n\r\nPackage [GoDoc](https://godoc.org/github.com/nbari/violetear)\r\n\r\nHow it works\r\n------------\r\n\r\nThe router is capable off handle any kind or URI, static,\r\ndynamic or catchall and based on the\r\n[HTTP request Method](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)\r\naccept or discard the request.\r\n\r\nFor example, suppose we have an API that exposes a service that allow to ping\r\nany IP address.\r\n\r\nTo handle only \"GET\" request for any IPv4 addresss:\r\n\r\n    http://api.violetear.org/command/ping/127.0.0.1\r\n                            \\______/\\___/\\________/\r\n                                |     |      |\r\n                                 static      |\r\n                                          dynamic\r\n\r\nThe router ``HandlerFunc``  would be:\r\n\r\n    router.HandleFunc(\"/command/ping/:ip\", ip_handler, \"GET\")\r\n\r\nFor this to work, first the regex matching ``:ip`` should be added:\r\n\r\n    router.AddRegex(\":ip\", `^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$`)\r\n\r\nNow let's say you also want to be available to ping ipv6 or any host:\r\n\r\n    http://api.violetear.org/command/ping/*\r\n                            \\______/\\___/\\_/\r\n                                |     |   |\r\n                                 static   |\r\n                                       catch-all\r\n\r\nA catch-all could be used and also a different handler, for example:\r\n\r\n    router.HandleFunc(\"/command/ping/*\", any_handler, \"GET, HEAD\")\r\n\r\nThe ``*`` indicates the router to behave like a catch-all therefore it\r\nwill match anything after the ``/command/ping/`` if no other condition matches\r\nbefore.\r\n\r\nNotice also the \"GET, HEAD\", that indicates that only does HTTP methods will be\r\naccepted, and any other will not be allowed, router will return a 405 the one\r\ncan also be customised.\r\n\r\n\r\nUsage\r\n-----\r\n\r\nhttp://gopkg.in/nbari/violetear.v2\r\n\r\nIf using ``go >= 1.7`` (using context form the standard library):\r\n\r\n    import \"gopkg.in/nbari/violetear.v2\"\r\n\r\n\r\nIf using ``go < 1.7``:\r\n\r\n    import \"gopkg.in/nbari/violetear.v1\"\r\n\r\n\r\n**HandleFunc**:\r\n\r\n     func HandleFunc(path string, handler http.HandlerFunc, http_methods ...string)\r\n\r\n**Handle** (useful for middleware):\r\n\r\n     func Handle(path string, handler http.Handler, http_methods ...string)\r\n\r\n**http_methods** is a comma separted list of allowed HTTP methods, example:\r\n\r\n    router.HandleFunc(\"/view\", handleView, \"GET, HEAD\")\r\n\r\n**AddRegex** adds a \":named\" regular expression to the dynamicRoutes, example:\r\n\r\n    router.AddRegex(\":ip\", `^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$`)\r\n\r\n\r\nBasic example:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"github.com/nbari/violetear\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc catchAll(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I'm catching all\\n\"))\r\n}\r\n\r\nfunc handleGET(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle GET requests\\n\"))\r\n}\r\n\r\nfunc handlePOST(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle POST requests\\n\"))\r\n}\r\n\r\nfunc handleUUID(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"I handle dynamic requests\\n\"))\r\n}\r\n\r\nfunc main() {\r\n    router := violetear.New()\r\n    router.LogRequests = true\r\n    router.RequestID = \"Request-ID\"\r\n\r\n    router.AddRegex(\":uuid\", `[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}`)\r\n\r\n    router.HandleFunc(\"*\", catchAll)\r\n    router.HandleFunc(\"/method\", handleGET, \"GET\")\r\n    router.HandleFunc(\"/method\", handlePOST, \"POST\")\r\n    router.HandleFunc(\"/:uuid\", handleUUID, \"GET,HEAD\")\r\n\r\n    log.Fatal(http.ListenAndServe(\":8080\", router))\r\n}\r\n```\r\n\r\nRunning this code will show something like this:\r\n\r\n```sh\r\n$ go run test.go\r\n2015/10/22 17:14:18 Adding path: * [ALL]\r\n2015/10/22 17:14:18 Adding path: /method [GET]\r\n2015/10/22 17:14:18 Adding path: /method [POST]\r\n2015/10/22 17:14:18 Adding path: /:uuid [GET,HEAD]\r\n```\r\n\r\n> test.go contains the code show above\r\n\r\nTesting using curl or [http](https://github.com/jkbrzt/httpie)\r\n\r\nAny request 'catch-all':\r\n\r\n```sh\r\n$ http POST http://localhost:8080/\r\nHTTP/1.1 200 OK\r\nContent-Length: 17\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:18:49 GMT\r\nRequest-Id: POST-1445527129854964669-1\r\n\r\nI'm catching all\r\n```\r\n\r\nA GET request:\r\n\r\n```sh\r\n$ http http://localhost:8080/method\r\nHTTP/1.1 200 OK\r\nContent-Length: 22\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:43:25 GMT\r\nRequest-Id: GET-1445528605902591921-1\r\n\r\nI handle GET requests\r\n```\r\n\r\nA POST request:\r\n\r\n```sh\r\n$ http POST http://localhost:8080/method\r\nHTTP/1.1 200 OK\r\nContent-Length: 23\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:44:28 GMT\r\nRequest-Id: POST-1445528668557478433-2\r\n\r\nI handle POST requests\r\n```\r\n\r\nA dynamic request using an [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) as the URL resource:\r\n\r\n```sh\r\n$ http http://localhost:8080/50244127-45F6-4210-A89D-FFB0DA039425\r\nHTTP/1.1 200 OK\r\nContent-Length: 26\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:45:33 GMT\r\nRequest-Id: GET-1445528733916239110-5\r\n\r\nI handle dynamic requests\r\n```\r\n\r\nTrying to use POST on the ``/:uuid`` resource will cause a\r\n*Method not Allowed 405* this because only ``GET`` and ``HEAD``\r\nmethods are allowed:\r\n\r\n```sh\r\n$ http POST http://localhost:8080/50244127-45F6-4210-A89D-FFB0DA039425\r\nHTTP/1.1 405 Method Not Allowed\r\nContent-Length: 19\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 15:47:19 GMT\r\nRequest-Id: POST-1445528839403536403-6\r\nX-Content-Type-Options: nosniff\r\n\r\nMethod Not Allowed\r\n```\r\n\r\nRequestID\r\n---------\r\n\r\nTo keep track of the \"requests\" an existing \"request ID\" header can be used, if\r\nthe header name for example is **Request-ID** therefore to continue using it,\r\nthe router needs to know the name, example:\r\n\r\n    router := violetear.New()\r\n    router.RequestID = \"X-Appengine-Request-Log-Id\"\r\n\r\nIf the proxy is using another name, for example \"RID\" then use something like:\r\n\r\n    router := violetear.New()\r\n    router.RequestID = \"RID\"\r\n\r\nIf ``router.RequestID`` is not set, no \"request ID\" is going to be added to the\r\nheaders. This can be extended using a middleware same has the logger check the\r\nAppEngine example.\r\n\r\n\r\nNotFoundHandler\r\n---------------\r\n\r\nFor defining a custom ``http.Handler`` to handle **404 Not Found** example:\r\n\r\n    ...\r\n\r\n    func my404() http.Handler {\r\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n            http.Error(w, \"ne ne ne\", 404)\r\n        })\r\n    }\r\n\r\n    func main() {\r\n        router := violetear.New()\r\n        router.NotFoundHandler = my404()\r\n        ...\r\n\r\nNotAllowedHandler\r\n-----------------\r\n\r\nFor defining a custom ``http.Handler`` to handle **405 Method Not Allowed**.\r\n\r\nPanicHandler\r\n------------\r\n\r\nFor using a custom http.HandlerFunc to handle panics\r\n\r\nMiddleware\r\n----------\r\n\r\nVioletear uses [Alice](http://justinas.org/alice-painless-middleware-chaining-for-go/) to handle [middleware](middleware).\r\n\r\nExample:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"context\"\r\n\t\"log\"\r\n\t\"net/http\"\r\n\r\n\t\"github.com/nbari/violetear\"\r\n\t\"github.com/nbari/violetear/middleware\"\r\n)\r\n\r\nfunc commonHeaders(next http.Handler) http.Handler {\r\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n\t\tw.Header().Set(\"X-app-Version\", \"1.0\")\r\n\t\tnext.ServeHTTP(w, r)\r\n\t})\r\n}\r\n\r\nfunc middlewareOne(next http.Handler) http.Handler {\r\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n\t\tlog.Println(\"Executing middlewareOne\")\r\n\t\tctx := context.WithValue(r.Context(), \"m1\", \"m1\")\r\n\t\tctx = context.WithValue(ctx, \"key\", 1)\r\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\r\n\t\tlog.Println(\"Executing middlewareOne again\")\r\n\t})\r\n}\r\n\r\nfunc middlewareTwo(next http.Handler) http.Handler {\r\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n\t\tlog.Println(\"Executing middlewareTwo\")\r\n\t\tif r.URL.Path != \"/\" {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tctx := context.WithValue(r.Context(), \"m2\", \"m2\")\r\n\t\tnext.ServeHTTP(w, r.WithContext(ctx))\r\n\t\tlog.Println(\"Executing middlewareTwo again\")\r\n\t})\r\n}\r\n\r\nfunc catchAll(w http.ResponseWriter, r *http.Request) {\r\n\tlog.Printf(\"Executing finalHandler\\nm1:%s\\nkey:%d\\nm2:%s\\n\",\r\n\t\tr.Context().Value(\"m1\"),\r\n\t\tr.Context().Value(\"key\"),\r\n\t\tr.Context().Value(\"m2\"),\r\n\t)\r\n\tw.Write([]byte(\"I catch all\"))\r\n}\r\n\r\nfunc foo(w http.ResponseWriter, r *http.Request) {\r\n\tpanic(\"this will never happen, because of the return\")\r\n}\r\n\r\nfunc main() {\r\n\trouter := violetear.New()\r\n\r\n\tstdChain := middleware.New(commonHeaders, middlewareOne, middlewareTwo)\r\n\r\n\trouter.Handle(\"/\", stdChain.ThenFunc(catchAll), \"GET,HEAD\")\r\n\trouter.Handle(\"/foo\", stdChain.ThenFunc(foo), \"GET,HEAD\")\r\n\trouter.HandleFunc(\"/bar\", foo)\r\n\r\n\tlog.Fatal(http.ListenAndServe(\":8080\", router))\r\n}\r\n```\r\n\r\n> Notice the use or router.Handle and router.HandleFunc when using middleware\r\nyou normally would use route.Handle\r\n\r\nRequest output example:\r\n\r\n```sh\r\n$ http http://localhost:8080/\r\nHTTP/1.1 200 OK\r\nContent-Length: 11\r\nContent-Type: text/plain; charset=utf-8\r\nDate: Thu, 22 Oct 2015 16:08:18 GMT\r\nRequest-Id: GET-1445530098002701428-3\r\nX-App-Version: 1.0\r\n\r\nI catch all\r\n```\r\n\r\nOn the server you will see something like this:\r\n\r\n```sh\r\n$ go run test.go\r\n2016/08/17 18:08:42 Adding path: / [GET,HEAD]\r\n2016/08/17 18:08:42 Adding path: /foo [GET,HEAD]\r\n2016/08/17 18:08:42 Adding path: /bar [ALL]\r\n2016/08/17 18:08:47 Executing middlewareOne\r\n2016/08/17 18:08:47 Executing middlewareTwo\r\n2016/08/17 18:08:47 Executing finalHandler\r\nm1:m1\r\nkey:1\r\nm2:m2\r\n2016/08/17 18:08:47 Executing middlewareTwo again\r\n2016/08/17 18:08:47 Executing middlewareOne again\r\n```\r\n\r\nAppEngine\r\n---------\r\n\r\nThe app.yaml file:\r\n\r\n```yaml\r\napplication: 'app-name'\r\nversion: 1\r\nruntime: go\r\napi_version: go1\r\n\r\nhandlers:\r\n\r\n- url: /.*\r\n  script: _go_app\r\n```\r\n\r\nThe app.go file:\r\n\r\n```go\r\npackage app\r\n\r\nimport (\r\n    \"appengine\"\r\n    \"github.com/nbari/violetear\"\r\n    \"github.com/nbari/violetear/middleware\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc init() {\r\n    router := violetear.New()\r\n    stdChain := middleware.New(requestID)\r\n    router.Handle(\"*\", stdChain.ThenFunc(index), \"GET, HEAD\")\r\n    http.Handle(\"/\", router)\r\n}\r\n\r\nfunc requestID(next http.Handler) http.Handler {\r\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\r\n        c := appengine.NewContext(r)\r\n        w.Header().Set(\"Request-ID\", appengine.RequestID(c))\r\n        next.ServeHTTP(w, r)\r\n    })\r\n}\r\n\r\nfunc index(w http.ResponseWriter, r *http.Request) {\r\n    w.Write([]byte(\"Hello world!\"))\r\n}\r\n```\r\n\r\nDemo: http://api.violetear.org\r\n\r\nUsing ``curl`` or ``http``:\r\n\r\n```sh\r\n$ http http://api.violetear.org\r\nHTTP/1.1 200 OK\r\nCache-Control: private\r\nContent-Encoding: gzip\r\nContent-Length: 32\r\nContent-Type: text/html; charset=utf-8\r\nDate: Sun, 25 Oct 2015 06:14:55 GMT\r\nRequest-Id: 562c735f00ff0902f823e514a90001657e76696f6c65746561722d31313037000131000100\r\nServer: Google Frontend\r\n\r\nHello world!\r\n```\r\n\r\nContext & Named parameters\r\n==========================\r\n\r\nIn some cases there is a need to pass data across\r\nhandlers/middlewares, for doing this **Violetear** uses\r\n[net/context](https://godoc.org/golang.org/x/net/context).\r\n\r\nExample:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"context\"\r\n    \"fmt\"\r\n    \"log\"\r\n    \"net/http\"\r\n\r\n    \"github.com/nbari/violetear\"\r\n)\r\n\r\nfunc catchAll(w http.ResponseWriter, r *http.Request) {\r\n    // Get & print the content of named-param *\r\n    params := r.Context().Value(violetear.ParamsKey).(violetear.Params)\r\n    fmt.Fprintf(w, \"CatchAll value:, %q\", params[\"*\"])\r\n}\r\n\r\nfunc handleUUID(w http.ResponseWriter, r *http.Request) {\r\n    // get router params\r\n    params := r.Context().Value(violetear.ParamsKey).(violetear.Params)\r\n    // add a key-value pair to the context\r\n    ctx := context.WithValue(r.Context(), \"key\", \"my-value\")\r\n    // print current value for :uuid\r\n    fmt.Fprintf(w, \"Named parameter: %q, key: %s\",\r\n        params[\":uuid\"],\r\n        ctx.Value(\"key\"),\r\n    )\r\n}\r\n\r\nfunc main() {\r\n    router := violetear.New()\r\n\r\n    router.AddRegex(\":uuid\", `[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}`)\r\n\r\n    router.HandleFunc(\"*\", catchAll)\r\n    router.HandleFunc(\"/:uuid\", handleUUID, \"GET,HEAD\")\r\n\r\n    log.Fatal(http.ListenAndServe(\":8080\", router))\r\n}\r\n```\r\n\r\n## Duplicated named parameters\r\n\r\nIn cases where the same named parameter is used multiple times, example:\r\n\r\n    /test/:uuid/:uuid/\r\n\r\nAn slice is created, for getting the values you need to do something like:\r\n\r\n        params := r.Context().Value(violetear.ParamsKey).(violetear.Params)\r\n        uuid := params[\":uuid\"].([]string)\r\n\r\n> Notice the ``:`` prefix when getting the named_parameters\r\n\r\nAfter this you can access the slice like normal:\r\n\r\n        fmt.Println(uuid[0], uuid[1])\r\n\r\n\r\n## Only for go < 1.7\r\n\r\nFor been available to use the **Context** ``ctx`` you need to do a type assertion:\r\n\r\n    cw := w.(*violetear.ResponseWriter)\r\n\r\nTo set a key-value pair you need to:\r\n\r\n    cw.Set(key, value)\r\n\r\nor\r\n\r\n    cw.ctx = context.WithValue(cw.ctx, \"key\", \"my-value\")\r\n\r\n\r\nTo retrieve a value:\r\n\r\n    cw.Get(value)\r\n\r\nor\r\n\r\n    cw.ctx.Value(\"key\")\r\n\r\n> You may need [Type assertions](https://golang.org/ref/spec#Type_assertions): ``cw.Get(value).(string)`` depending on your needs.\r\n\r\n\r\nMore references:\r\n\r\n* https://tip.golang.org/doc/go1.7#context\r\n* https://justinas.org/alice-painless-middleware-chaining-for-go/\r\n* http://www.alexedwards.net/blog/making-and-using-middleware\r\n* https://golang.org/ref/spec#Type_assertions\r\n\r\n\r\nCanonicalized headers issues\r\n----------------------------\r\n\r\nGo version < 1.5 will canonicalize the header (from uppercase to lowercase),\r\nexample:\r\n\r\nhttps://travis-ci.org/nbari/violetear/jobs/81059152#L156 golang 1.4\r\n\r\nhttps://travis-ci.org/nbari/violetear/jobs/81059153#L156 golang 1.5\r\n",
  "google": "UA-69163599-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}